# BigTable review

A distributed storage system for managing structed data.

## Introduction

1) Dose not support full relational data model

2) It provides clients with a simple data model which support the dynamic control over data layout and format.

3) Data is indexed using row and column names that can be arbirtary strings.



## Data model

sparse, distributed, persistent multi-dimensional sorted map!

map is indexed by a row key, column key and a timestamp.

each value is an uniterpreted array of bytes.

![1624361585121](https://vintmd.github.io/photo/1624361585121.png)

### Rows

Every read and write under a single row key is atomic, maintains data in lexicographic order by row key.

Each row range is call the tablet, which is unit of distribution and load balancing.

![1624362432881](https://vintmd.github.io/photo/1624362432881.png)

1) row keys are organize in lexicographic order;

2) the range of row is call the tablet;

3) client can store the rows key to same prefix(reverse the url) to achieve the range query.



### Column Families

intent  the number of distinct column families in a table be small, a tale may have an unbounded number of columns.

a column key is named using the following syntax: family:qualifier.



### Timestamps

Contain mult versions of the same data; these versions are indexed by timestamp.



## Building blocks

Uses the distributed GFS to store log and data files.

### SSTable

SSTable file format is used internally to store data

![1624414649922](https://vintmd.github.io/photo/1624414649922.png)

SSTable sparse index in memory, the block write can append file on disk(compressible block). when update the value to update the offset which append to new space. it can support batch create effectiveness.



SSTable support two way to compact

1) size-tiered: limit the number of sstable in each level

2) leveled: each level sstable size is different, merge the sstables which has the same part of data to higher level, each different part merge is concurrent. 



Bigtable relies on a highly-avaiable and persistent distributed lock service called Chubby which uses the paoxs to keep its replicas consistent in the face of failure.

Chubby used in:

1) ensure at most one master.

2) store the bootstrap location of bigtable data.

3) to discover tablet servers and finalize tablet server death

4) to store bigtable schema infomation(the column family information for each table)

5) to store access control list.



## Implementation

![1624448348081](https://vintmd.github.io/photo/1624448348081.png)

master: assign tablets to tablet server,  detect addition and expiration of tablet server, load balance and GFS GC

tablet server: contain batch of tablets(row range), handle the read and write to the tablets it load.

client: no need to ask the location of tablet server, direct communcate to tablet server to read and write.



### Table Location

![1624448788760](https://vintmd.github.io/photo/1624448788760.png)

1) chubby file contains the location of root tablet.

2) root tablet contains the location of all tablets in a special metadata table,  the root tablet is just first tablet in the metadata table which never split.

3) client cache  tablet location. 



### Tablet assignment

![1624499685243](https://vintmd.github.io/photo/1624499685243.png)

when start the tablet server it create unique named file in chubby dir, this directory also can used for starting master to detect current alive tablet server.

if the tablet server's chubby session timeout or release the exclusive lock the master can detect it.

the master scan the metadata table to get the each tablet location.



### Tablet Serving

![1624499904634](https://vintmd.github.io/photo/1624499904634.png)

memtable load the sstable files into memory and according to the checkpoint to apply the data.

the tablet log and sstable files are store in gfs.

after the writre has been committed, it contents are inserted into the memetable.

* it is same to the ofs, memory dir engine's recover. 



### Compactions

memtable(size threshold) and sstable files(contains same part) to merge into a new sstable which contains no deletion information or deleted data. The way sames to the LSM tree.



## Refinements

### Locality group

clients can group multi column families together into a local group.

stablet server can load these group sstable into memory(same locality group sstable data is sequence, which can be used by block cache to improve the read efficiency)

### Compression

large content use the compression algorithm or a large locality group to compress.

### Cache for read performance

![1624503335639](https://vintmd.github.io/photo/1624503335639.png)

1) high level cache scan cache: store the kv pairs

2) low level cache block cache: store the sstable blocks on gfs(sstable is sequnce store new data)

### Bloom filters

no need to read from all sstables that make up the state of a tablet(whether contains the key).

### Commit-log implementation

give the sequnce number to the log entries to avoid load same row log from different down tablet server.

### Speeding up tablet recovery

minor compaction reduce the recovery time.

### Exploiting immutability

sstable is immutable, memtable is mutable. 

immutable make the concurrency control over rows very efficienty.

memetable use the copy on write allow reads and writes to processd in parallel.

## Performance

random, sequence write and read, IOPS, qps, throughput, recover time.



## Real applications

google Analytics , google earth, facebook. nosql



## Reference

[1] https://hbase.apache.org/

[2] https://juejin.cn/post/6844904190968332295

[3] https://zhuanlan.zhihu.com/p/103855686

[4] https://zhuanlan.zhihu.com/p/181498475

[5] https://shashankbaravani.medium.com/database-storage-engines-under-the-hood-705418dc0e35

[6] https://research.google/pubs/pub27898/

